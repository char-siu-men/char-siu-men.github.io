<!doctype html><html dir=ltr lang=ja><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=alternate hreflang=ja href=https://www.altus5.co.jp/ ><title>AngularJS vs React それぞれの利点と特徴（Angular編） | ALTUS-FIVE</title><meta name=description content="「Angular 2」「React」両フレームワークでToDoツールを作成する記事です。実装過程と成果物を比較して、両者のフレームワークの良いところ・悪いところを検証したいと思います。（Angular編）"><meta name=viewport content="width=device-width,initial-scale=1"><meta property=og:title content="AngularJS vs React それぞれの利点と特徴（Angular編） | ALTUS-FIVE"><meta property=og:type content=website><meta property=og:url content=https://www.altus5.co.jp><meta property=og:description content="「Angular 2」「React」両フレームワークでToDoツールを作成する記事です。実装過程と成果物を比較して、両者のフレームワークの良いところ・悪いところを検証したいと思います。（Angular編）"><meta property=og:site_name content=ALTUS-FIVE><meta property=og:image content=https://www.altus5.co.jp/images/ogp.png><meta name=twitter:card content=summary><meta name=twitter:url content=https://www.altus5.co.jp><meta name=twitter:title content="AngularJS vs React それぞれの利点と特徴（Angular編） | ALTUS-FIVE"><meta name=twitter:description content="「Angular 2」「React」両フレームワークでToDoツールを作成する記事です。実装過程と成果物を比較して、両者のフレームワークの良いところ・悪いところを検証したいと思います。（Angular編）"><meta name=twitter:image content=https://www.altus5.co.jp/images/ogp.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple_touch_icon180x180.png><link rel=apple-touch-icon sizes=152x152 href=/images/apple_touch_icon152x152.png><link rel=apple-touch-icon sizes=120x120 href=/images/apple_touch_icon120x120.png><link rel=apple-touch-icon sizes=76x76 href=/images/apple_touch_icon76x76.png><link href=https://www.altus5.co.jp/feed.xml rel=alternate type=application/atom+xml><link rel=stylesheet href=/styles/common.css><link rel=stylesheet href=/styles/blog.css><body><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5WGNWC" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5WGNWC');</script><!--[if lt IE 9]>
    <p class="browserupgrade">
      <strong>古い</strong>ブラウザをご使用されています。
      本サイトを快適に閲覧頂くために、<a href="http://browsehappy.com/">新しいブラウザにアップグレード</a>してください。
    </p>
  <![endif]--><header id=_header><nav class="w_const cf"><h1 class=logo_head><a href=/ ><img src=/images/logo_header.png alt=ALTUS-FIVE（アルタスファイブ）></a></h1><ul class=links><li class=link><a href=/#introduction>アルタスファイブとは</a><li class=link><a href=/#feature>強み</a><li class=link><a href=/#service>サービス</a><li class=link><a href=/#performance>実績</a><li class=link><a href=/#example>開発事例</a><li class=link><a href=/blog/ >ブログ</a><li class=link><a href=/recruit/ >採用情報</a><li class=link><a href=/company/ >会社概要</a><li class="link link_contact"><a href=/contact/ >お問い合わせ</a></ul></nav></header><div id=blog_page class=wrap_all><article id=blog class=article><section class="blog__title w_const"><span>AngularJS vs React それぞれの利点と特徴（Angular編）</span></section><div class="article__conts w_const cf"><div id=blog-content><div id=blog-subtitle class=cf><div id=blog-date>2017/01/30</div><div id=blog-tags><ul class=tag-uline><li class="tag-uline-label tag__0"><a href=/blog/tag/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E6%8A%80%E8%A1%93%E7%B7%8F%E8%A6%A7/ >プログラミング技術総覧</a><li class="tag-uline-label tag__7"><a href=/blog/tag/AngularJS/ >AngularJS</a><li class="tag-uline-label tag__8"><a href=/blog/tag/React/ >React</a></ul></div></div><div class=markdown-body><h2 id=react-or-angular-2->React or Angular 2 ー どちらを使うべきか</h2><p>筆者は普段バックエンド担当をしており、フロントエンドの世界に深い知見を持っておりません。しかし、JavaScript界隈の進化のスピードの速さには、日々驚かされます。フレームワークの数も今や膨大な数になっています。<p>その中でも選択肢に上がりやすいのがFacebook Inc.が開発している「React.js」、そしてGoogleが開発している「AngularJS」ではないかと思います。 これらのフレームワークの良さは、小規模なプロジェクトでよいので、開発を行ってみて初めて違いがわかるものだと思います。<p>なので、今回は両方のフレームワークで同じツールを作成し、実装過程と成果物を比較して、両者のフレームワークの良いところ・悪いところを検証したいと思います。<h3 id=-todo->目標 - ToDoツールの実装</h3><p>以下の機能を持つ、簡単なToDoツールを作成します。<ul><li>タスクの登録<li>タクスの削除<li>タスクの完了</ul><p><img src=/images/blog/react-vs-angularjs/image1.jpg alt=(図1)><p>まず最初に、それぞれのフレームワークの概要を記載します。<h3 id=react->Reactの概要</h3><ul><li>Facebook Inc.が開発<li>MVCでいうView部分のみをサポートしたフレームワーク<li>Viewのみなので、他のJSフレームワークとの連携も可能<li>JSXというJavaScriptの拡張文法を用いることができ、コード内にHTMLに似た記述ができる<li>仮想DOMと呼ばれるレンダリング機能がある。（詳しくはReactの章で記載）</ul><h3 id=angular-2->Angular 2の概要</h3><ul><li>GoogleとMicrosoftが共同で開発（Microsoftの参画はAngular 2から）<ul><li>AngularJS 1とAngular 2は互換性が低い</ul><li>コンポーネントベースである<li>フルスタックフレームワークである<li>Angular 2やAngular 1.xでは、TypeScriptでの記述が可能になった</ul><h2 id=angular-2-todo->Angular 2でToDoツールを実装する</h2><p>ちなみに、Angular4が2017年3月にリリース予定ですが、Angular 2と互換性があるということなので、Angular 2を勉強しておいて損は無いと思います。<h3 id=angular-2->Angular 2はフルスタックフレームワーク</h3><p>Angular 2はフルスタックフレームワークであり、開発に必要なものはすべて含まれています。例えば、Vue.jsではルーティングのためにVue Routerを使用しますが、Angular 2には標準でルーティング機能が備わっています。 また、ユニットテストや、KarmaやJasmineによるE2Eテストも非常に組み込みやすくなっています。<h3 id=angular-2-typescript->Angular 2はTypeScriptで書ける</h3><p>Angular 2の何よりの特徴は、TypeScriptで書くことを前提に設計されているところです。Microsoftの参画によりTypeScriptが採用されることになり、同言語の機能が使えるようになりました。 そのため、クラスや継承といった概念を使用しやすく、コードの品質を低いコストで保つことができます。<p>もちろんBabelなどを使用してES6やES5でも書けますが、Angular公式はあくまでTypeScriptを推奨しています。<h4 id=->コンポーネント指向</h4><p>Angular 1ではMVCやMVW(Model-View-Whatever)というデザインパターンが採用されてきましたが、Angular 2からはコンポーネント指向で設計されるようになりました。 コンポーネントごとにプログラムを分けることができるので、わかりやすい設計を行うことができます。<p><img src=/images/blog/react-vs-angularjs/image2.jpg alt=(図2)><p>例えば、今回作るToDoツールの場合は、上記のように3つのコンポーネントに分ける形で実装していきます。 この特徴のため、Angular 2はAngular 1よりも大きなアプリケーションの開発に向いていると言われています。<h3 id=angular-2-todo->Angular 2でToDoを作成する</h3><p>今回作成するToDoツールの最終的なディレクトリ構造は以下のようになります。(最後にビルドされると、.jsファイル等が生成されます）<pre><code>.
├── app
│   ├── app.component.ts
│   ├── app.html
│   ├── app.module.ts
│   ├── components
│   │   ├── content
│   │   │   ├── content.component.ts
│   │   │   └── content.html
│   │   ├── footer
│   │   │   ├── footer.component.ts
│   │   │   └── footer.html
│   │   └── header
│   │       ├── header.component.ts
│   │       └── header.html
│   ├── main.ts
│   ├── models
│   │   └── todo.model.ts
│   └── services
│       └── todo.service.ts
├── index.html
├── node_modules
├── package.json
├── systemjs.config.js
└── tsconfig.json
</code></pre><p>app以下にアプリケーションのコードを配置していきます。<ul><li>components<ul><li>コンポーネントのパーツを配置していく<li>今回は「header」、「content」、「footer」のように分けた</ul><li>models<ul><li>モデルを配置する</ul><li>service<ul><li>ロジックを書くサービス層</ul></ul><h3 id=->インストール</h3><p>以下のpackage.jsonを用意します。<p>nodeとnpmは必須なので下記を参考にインストールしてください。 nodeは4.x.x以上、npmは3.x.x以上が必須要件です。<p><a href=https://docs.npmjs.com/getting-started/installing-node>・npmjs.com 02 - Installing Node.js and updating npm _ npm Documentation</a><pre><code>{
  &quot;name&quot;: &quot;angular-quickstart&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;QuickStart package.json from the documentation, supplemented with testing support&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;tsc &amp;&amp; concurrently \&quot;tsc -w\&quot; \&quot;lite-server\&quot; &quot;,
    &quot;lite&quot;: &quot;lite-server&quot;,
    &quot;tsc&quot;: &quot;tsc&quot;,
    &quot;tsc:w&quot;: &quot;tsc -w&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;dependencies&quot;: {
    &quot;@angular/common&quot;: &quot;~2.4.0&quot;,
    &quot;@angular/compiler&quot;: &quot;~2.4.0&quot;,
    &quot;@angular/core&quot;: &quot;~2.4.0&quot;,
    &quot;@angular/forms&quot;: &quot;~2.4.0&quot;,
    &quot;@angular/http&quot;: &quot;~2.4.0&quot;,
    &quot;@angular/platform-browser&quot;: &quot;~2.4.0&quot;,
    &quot;@angular/platform-browser-dynamic&quot;: &quot;~2.4.0&quot;,
    &quot;@angular/router&quot;: &quot;~3.4.0&quot;,

    &quot;angular-in-memory-web-api&quot;: &quot;~0.2.4&quot;,
    &quot;systemjs&quot;: &quot;0.19.40&quot;,
    &quot;core-js&quot;: &quot;^2.4.1&quot;,
    &quot;rxjs&quot;: &quot;5.0.1&quot;,
    &quot;zone.js&quot;: &quot;^0.7.4&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;concurrently&quot;: &quot;^3.1.0&quot;,
    &quot;lite-server&quot;: &quot;^2.2.2&quot;,
    &quot;typescript&quot;: &quot;~2.0.10&quot;,

    &quot;canonical-path&quot;: &quot;0.0.2&quot;,
    &quot;http-server&quot;: &quot;^0.9.0&quot;,
    &quot;lodash&quot;: &quot;^4.16.4&quot;,
    &quot;protractor&quot;: &quot;~4.0.14&quot;,
    &quot;rimraf&quot;: &quot;^2.5.4&quot;,

    &quot;@types/node&quot;: &quot;^6.0.46&quot;,
    &quot;@types/jasmine&quot;: &quot;^2.5.36&quot;
  },
  &quot;repository&quot;: {}
}
</code></pre><p>特徴としてはTypeScriptで書き、lite-serverを使用しているところです。 lite-serverでローカルサーバを起動させつつ、ファイルの変更を監視することができます。 Package.jsonが準備できたらインストールを開始します。<pre><code>$ npm install
</code></pre><p>開発中は以下コマンドでサーバを実行してください。<pre><code>$ npm start
</code></pre><h3 id=->コンポーネントとモジュール</h3><p>Angular 2はコンポーネント指向だと先ほど説明しましたが、その基本は2つの要素から成ります。<ul><li>コンポーネント<li>モジュール</ul><h4 id=->コンポーネント</h4><p>Angular 2のコンポーネントはメタデータとロジックを持ちます。<pre><code>@Component({
  selector: &#39;my-app&#39;,
  template: &#39;&lt;h1&gt;Hello!!&lt;/h1&gt;&#39;,
})

export class AppComponent {}
</code></pre><p>上記コードでは<code>AppComponent</code>という名前でコンポーネントを定義しています。<p><code>@Component</code>で指定された部分がメタデータです。ここにテンプレートであるHTMLなどを指定し、Viewを持ちます。そして<code>selector</code>で指定されたタグに、templateを表示します。<p>@Componentで定義したテンプレートを、HTMLでレンダリングするためには以下のコードを記述します。<pre><code>&lt;body&gt;
    &lt;my-app&gt;&lt;/my-app&gt;
&lt;/body&gt;
</code></pre><p>上記コードは、<code>@Component</code>で指定したselectorをHTMLに定義しています。HTMLにselectorを指定すると、<code>@Component</code>のtemplateで定義したテンプレートがレンダリングされます。<h4 id=->モジュール</h4><p>コンポーネントなどの実装をグループ化したものです。Angular 2も多数のモジュールから成り立っています。 ルールとして、webページを作成する際は、最低一つのモジュールを含む必要があります。(これをルートモジュールと呼びます。)<pre><code>import { BrowserModule }  from &#39;@angular/platform-browser&#39;;
import { NgModule }       from &#39;@angular/core&#39;;
import { AppComponent }   from &#39;./app.component&#39;;

@NgModule({
  imports: [
    BrowserModule,
  ],
  declarations: [
    AppComponent,
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code></pre><p>まずimportで必要なモジュールを取り込みます。BrowserModuleはWebページを表示するために使用するモジュールです。 @NgModuleというデコレータでメタデータを読み込んで、 <code>AppModule</code>という名前をモジュールにつけています。今回は、だいたいの定義の仕方は、コンポーネントと変わりないですね。<p>@NgModuleでメタデータを定義します。引数の値は、下記のようになります。<ul><li>imports<ul><li>モジュールが必要とする他のモジュールを<code>import</code>します</ul><li>declarations<ul><li>モジュールが含むコンポーネントを指定します</ul><li>bootstrap<ul><li>ブラウザからアクセスされた際に、初めに表示されるコンポーネントを指定します</ul></ul><h3 id=todo->ToDoのルートコンポーネントとルートモジュールを用意する</h3><p>まずは初めに読み込まれる<code>index.html</code>を用意します。<pre><code>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Angular 2 ToDo&lt;/title&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

    &lt;script src=&quot;node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;

    &lt;script src=&quot;node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;

    &lt;script src=&quot;systemjs.config.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      System.import(&#39;app&#39;).catch(function(err){ console.error(err); });
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;my-app&gt;&lt;/my-app&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>scriptで必要なnode_moduleを読み込んでいる他に、System.jsを利用しています。Angular 2ではSystem.jsが採用されています。<p>System.jsを利用すると、大量の<code>&lt;script&gt;</code>タグを書かずに済み、読み込みの順番も気にせずに使用することができます。 また、開発環境でモジュールごとにファイルを分けることもできます。<pre><code>System.import(&#39;app&#39;).catch(function(err){ console.error(err); });
</code></pre><p>先ほど説明したように、<code>&lt;my-app&gt;</code>というタグ内にコンポーネントが表示されます。<pre><code>&lt;body&gt;
    &lt;my-app&gt;&lt;/my-app&gt;
&lt;/body&gt;
</code></pre><h4 id=->ルートコンポーネント</h4><p>まずはルートコンポーネント(app/app.component.ts)を用意します。<pre><code>import {Component} from &#39;@angular/core&#39;;

@Component({
  selector: &#39;my-app&#39;,
  templateUrl: &#39;app/app.html&#39;,
})

export class AppComponent {
}
</code></pre><p><code>selector</code>には先ほどindex.htmlにあった<code>my-app</code>タグに、<code>templateUrl</code>で指定したapp/app.htmlが表示されます。<p>app/app.htmlの中身は以下のようになります。<pre><code>&lt;section class=&quot;container&quot;&gt;
  &lt;todo-header&gt;&lt;/todo-header&gt;
  &lt;todo-content [todos]=&quot;todos&quot;&gt;&lt;/todo-content&gt;
  &lt;todo-footer [todos]=&quot;todos&quot;&gt;&lt;/todo-footer&gt;
&lt;/section&gt;
</code></pre><p><code>todo-header</code>、<code>todo-content</code>、<code>todo-footer</code>をそれぞれ指定します。各コンポーネントごとにviewを作成できるので、非常にスッキリとした見た目になります。 各コンポーネントについては後ほど説明します。<h4 id=-app-app-module-ts->ルートモジュール(app/app.module.ts)</h4><p>同様に、ルートモジュール(app/app.module.ts)を用意します。<pre><code>import { BrowserModule }  from &#39;@angular/platform-browser&#39;;
import { FormsModule }    from &#39;@angular/forms&#39;;
import { NgModule }       from &#39;@angular/core&#39;;
import { AppComponent }   from &#39;./app.component&#39;;
import { TodoService }    from &#39;./services/todo.service&#39;;
import {TodoHeaderComponent} from &#39;./components/header/header.component&#39;;
import {TodoContentComponent} from &#39;./components/content/content.component&#39;;
import {TodoFooterComponent} from &#39;./components/footer/footer.component&#39;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule
  ],
  declarations: [
    AppComponent,
    TodoHeaderComponent,
    TodoContentComponent,
    TodoFooterComponent,
  ],
  providers: [
    TodoService,
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code></pre><p><code>declarations</code>で各コンポーネントを読み込みます。その他、必要なモジュールもimportします。<h5 id=angular-2-di>Angular 2のDI</h5><p>Angular 2ではサービスクラスを使用する際はDIを利用します。 ここでDIとはDependency Injectionの略であるため、「依存性の注入」？と直訳してしまいがちなのですが、この和訳ではよく意味が通りませんね。詳しく説明をしていきましょう。 今回のケースでDependency（依存性）とは、インスタンスがもつサービスクラスへの依存性を指しています。下記コードのTestComponentは、TodoSeriviceというサービスクラスを利用するコンポーネントとして定義されていますので、本質的にTodoSeriviceに依ったクラスです。<pre><code>export class TestComponent {
  constructor(private service:TodoService) {}
}
</code></pre><p>ここで、利用するサービスクラスは事前に<code>providers</code>で設定されているものとします。<pre><code>providers: [
    TodoService,
],
</code></pre><p>TestComponentクラスは、サービスを引数として外部から受け取ることでDIを実現しています。TestComponentの依存先であるTodoServiceクラスを、インスタンス生成の際に引数として渡すような設計とすることで、外から柔軟に「注入」できるようになっています。これが依存性の注入…というより、「依存先の注入」というのがより適切な訳語かもしれませんね。<p>なぜDIが推奨されるかというと、各クラス同士の依存性を緩和するためです。<p>たとえば、以下のTestComponentDependingクラスの設計は、TodoServiceクラスに強く依存している状態といえます。<pre><code>class TestComponentDepending {
    service:TodoService = new TodoService();
}
</code></pre><p>一方、DIを利用したTestComponentクラスの場合、TodoServiceクラスを継承した別のクラスも引数として渡せます。よって、クラスの利用者がTestComponentクラスの中身を書き換えることなく、いろいろなサービスクラスを渡せるようになり、拡張性が高くなるのです。<h4 id=app-services-todo-service-ts>app/services/todo.service.ts</h4><p>ロジックの部分を決めるサービスクラスを定義していきます。<pre><code>import {Injectable} from &quot;@angular/core&quot;;
import {Todo} from &quot;../models/todo.model&quot;;

const STORAGE_KEY = &#39;angular2-todo&#39;;


@Injectable()
export class TodoService {

  todos:Todo[] = [];

  constructor() {
  }

  add(title:string):void {
    let newTodo = new Todo(
      Math.floor(Math.random() * 100000), // ランダムにIDを発番する
      title,
      false
    );
    this.todos.push(newTodo);
  }

  remove(todo:Todo):void {
    const index = this.todos.indexOf(todo);
    this.todos.splice(index, 1);
  }

  toggleComplate(todo:Todo):void {
    this.todos.filter(t =&gt; t.id === todo.id)
      .map(t =&gt; t.isCompleted = !t.isCompleted);
  }

  getComplatedCount():number {
    return this.todos.filter(todo =&gt; todo.isCompleted).length;
  }
}
</code></pre><p>Todoモデルを読み込んで、タスクを追加する<code>add</code>、削除する<code>remove</code>、完了のフラグを管理する<code>toggleComplate</code>、完了の件数を数える<code>getComplatedCount</code>を追加します。<h4 id=app-models-todo-model-ts>app/models/todo.model.ts</h4><pre><code>export class Todo {
  constructor(public id:number,
              public title:string,
              public isCompleted:boolean) {
  }
}
</code></pre><p>モデルについては必要な属性を定義するだけです。<h4 id=header>header</h4><p>最後にそれぞれのcomponentを作成していきます。それぞれコンポーネントごとにクラス定義し、テンプレートとなるhtmlを準備していきます。 まずはタスク追加フォームを定義するheaderを作成します。<ul><li>app/components/header/header.component.ts<li>app/components/header/header.html</ul><pre><code>&lt;header&gt;
  &lt;h1&gt;Todos&lt;/h1&gt;
  &lt;form&gt;
    &lt;div&gt;
      &lt;label&gt;新しいTodo：&lt;/label&gt;
      &lt;input name=&quot;title&quot; [(ngModel)]=&quot;title&quot;&gt;
    &lt;/div&gt;
    &lt;button  (click)=&quot;addTodo()&quot;&gt;追加&lt;/button&gt;
  &lt;/form&gt;
&lt;/header&gt;
</code></pre><p>テキストフォームの値をviewからバインディングするために、<code>(ngModel)</code>を使用します。<code>tittle</code>という名前で<code>header.component.ts</code>で取得できるようにします。<p>またタスクの追加ができるformのbutton要素にclickイベントを追加します。Angular 2では<code>(click)={method_name}</code>で設定できます。<p>ロジック部分は<code>TodoService</code>クラスを使用するため、ここでも<code>constructor</code>にてDIを利用して定義しています。<pre><code>import {Component} from &#39;@angular/core&#39;;
import {TodoService} from &#39;../../services/todo.service&#39;;

@Component({
  selector: &#39;todo-header&#39;,
  templateUrl: &#39;app/components/header/header.html&#39;
})

export class TodoHeaderComponent {

  title:string;

  constructor(private service:TodoService) {}

  addTodo() {
    if (this.title != null &amp;&amp; this.title.trim().length) {
      this.service.add(this.title);
      this.title = null;
    }
  }
}
</code></pre><p>先ほどの<code>ngModel</code>の値をバインディングするために、<code>title:string</code>を設定します。そしてclickイベントで設定した<code>addTodo</code>を追加します。<pre><code>title:string;
</code></pre><h5 id=-component>@Component</h5><p>メタ要素を定義します。<code>templateUrl</code>でテンプレートとなるviewのパスを指定します。そしてそのテンプレートの中身を<code>selector</code>で表示するタグ名を設定します。<h4 id=component>component</h4><p>追加されたタスクの一覧を表示します。各タスクの削除、タスクの完了のチェックボックスなどもここに表示します。<ul><li>app/components/content/content.component.ts<li>app/components/content/content.html</ul><pre><code>&lt;ul class=&quot;list-group&quot;&gt;
  &lt;li class=&quot;list-group-item&quot; *ngFor=&quot;let todo of todos; let i = index&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col-xs-10&quot;&gt;
        &lt;label&gt;
          &lt;input type=&quot;checkbox&quot;
                 (click)=&quot;toggleComplate(todo)&quot;
                 [checked]=&quot;todo.isCompleted&quot;&gt;
        &lt;/label&gt;
        &lt;span [class.complate]=&quot;todo.isCompleted&quot;&gt;
          \{\{i + 1\}\}. \{\{todo.title\}\}
        &lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;col-xs-2&quot;&gt;
         &lt;button class=&quot;btn btn-link&quot; (click)=&quot;deleteTodo(todo)&quot;&gt;削除&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li class=&quot;list-group-item text-danger&quot; *ngIf=&quot;!todos.length&quot;&gt;Todoがありません。&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>繰り返しには<code>ngFor</code>ディレクティブを使用します。<code>Ngfor</code>ディレクティブを利用すると、以下のローカル変数が自動的に使用することができます。 今回はindex変数を利用して、現在のindex番号を表示しています。<ul><li>index<ul><li>現在処理されているオブジェクトのオフセット番号</ul><li>last<ul><li>最後のオブジェクトのときにtrueを返す</ul><li>even<ul><li>indexが偶数のときにtrueを返す</ul><li>todd<ul><li>indexが奇数のときにtrueを返す</ul></ul><pre><code>[checked]=&quot;todo.isCompleted&quot;
</code></pre><p>タスクの完了フラグを変更するためにチェックボックスを使用します。チェックボックスでバインディングするためには<code>checked</code>を利用します。<pre><code>import {Component, Input} from &#39;@angular/core&#39;;
import {Todo} from &quot;../../models/todo.model&quot;;
import {TodoService} from &quot;../../services/todo.service&quot;;

@Component({
  selector: &#39;todo-content&#39;,
  templateUrl: &#39;app/components/content/content.html&#39;
})

export class TodoContentComponent {
  @Input()
  todos:Todo[];

  constructor(private service:TodoService) { }

  ngOnInit(): void {
    this.todos = this.service.todos;
  }

  toggleComplate(todo:Todo) {
    this.service.toggleComplate(todo);
  }

  deleteTodo(todo:Todo) {
    this.service.remove(todo);
  }
}
</code></pre><p>基本的にはheaderと同じ作りになります。<code>@Component</code>でメタデータを定義して、クラスにviewのイベントで必要なメソッドを定義していきます。<h5 id=-input-ngoninit>@InputとngOnInit</h5><p>viewとコンポーネントの間にはLifecycle Hooksという仕組みがあり、コンポーネントの生成や破棄されるタイミングでコールバックの関数を指定できます。 コンポーネントが持っているデータの更新や（今回の場合はtodos）、viewを更新した場合の変更を検知できます。<p>今回コンポーネントで定義されている<code>todos</code>はこのLifecycle Hooksを利用して実行できるようにしています。<pre><code>@Input()
todos:Todo[];
</code></pre><pre><code>ngOnInit(): void {
    this.todos = this.service.todos;
}
</code></pre><p><code>ngOnInit()</code>を利用すると、@Input()でデータバインドされた入力値を初期化後に実行することができます。つまり<code>this.service.todos</code>で取得したtodosをすぐにviewに反映することができるのです。<p>そのほかの<code>Lifecycle Hooks</code>に関するメソッドも記載しておきます。<ul><li>ngOnChanges<ul><li>@Input()でデータバインドされた入力値が変更するたびに実行されます。</ul><li>ngDoCheck<ul><li>すべての変更を検出すると呼ばれます。</ul><li>ngOnDestroy<ul><li>コンポーネントを削除する前に呼ばれます。</ul></ul><h4 id=footer>footer</h4><p>最後にフッターを定義します。フッターにはタスクの合計数と、「完了」のチェックボックスにマークをつけた数を表示します。<ul><li>app/components/footer/footer.component.ts<li>app/components/footer/footer.html</ul><pre><code>&lt;footer class=&quot;container&quot;&gt;
  &lt;p *ngIf=&quot;todos&quot;&gt;Todo消化状況： \{\{getCompletedCount()\}\} / \{\{todos.length\}\}&lt;/p&gt;
&lt;/footer&gt;
</code></pre><p><code>ngIf</code>ディレクティブを利用して、todosが存在する場合のみに表示するようにしています。<pre><code>import {Component, Input} from &#39;@angular/core&#39;;
import {TodoService} from &#39;../../services/todo.service&#39;;
import {Todo} from &quot;../../models/todo.model&quot;;

@Component({
  selector: &#39;todo-footer&#39;,
  templateUrl: &#39;app/components/footer/footer.html&#39;
})
export class TodoFooterComponent {
  @Input()
  todos:Todo[];

  constructor(private service:TodoService) {}

  ngOnInit(): void {
    this.todos = this.service.todos;
  }

  getCompletedCount() {
    return this.service.getComplatedCount();
  }
}
</code></pre><p>基本的には今まで作成してきたコンポーネントとほぼ作りは同じです。 <code>ngOnInit</code>でtodosを取得して、<code>@Input()</code>を利用してviewとデータをバインディングさせている他、<code>@Component</code>でメタデータを定義しています。<h4 id=-app-app-module-ts->ルートモジュール(app/app.module.ts)</h4><p>すべてのコンポーネントを定義したあとに再びルートモジュールの定義を見てみましょう。<pre><code>import { BrowserModule }  from &#39;@angular/platform-browser&#39;;
import { FormsModule }    from &#39;@angular/forms&#39;;
import { NgModule }       from &#39;@angular/core&#39;;
import { AppComponent }   from &#39;./app.component&#39;;
import { TodoService }    from &#39;./services/todo.service&#39;;
import {TodoHeaderComponent} from &#39;./components/header/header.component&#39;;
import {TodoContentComponent} from &#39;./components/content/content.component&#39;;
import {TodoFooterComponent} from &#39;./components/footer/footer.component&#39;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule
  ],
  declarations: [
    AppComponent,
    TodoHeaderComponent,
    TodoContentComponent,
    TodoFooterComponent,
  ],
  providers: [
    TodoService,
  ],
  bootstrap: [ AppComponent ]
})
</code></pre><p>作成したコンポーネントをメタデータとして、<code>declarations</code>で登録しているのがわかると思います。<pre><code>&lt;section class=&quot;container&quot;&gt;
  &lt;todo-header&gt;&lt;/todo-header&gt;
  &lt;todo-content [todos]=&quot;todos&quot;&gt;&lt;/todo-content&gt;
  &lt;todo-footer [todos]=&quot;todos&quot;&gt;&lt;/todo-footer&gt;
&lt;/section&gt;
</code></pre><p><code>app/app.html</code>の中身も再び見てみましょう。それぞれのコンポーネントで設定されたタグが定義されています。 さら <code>content</code>や<code>footer</code>の<code>todos</code>はここに定義されています。<h3 id=angular-2->Angular 2についてのまとめ</h3><ul><li>コンポーネント指向なので各パーツごとに分けることができ、ソースコードを分割できる<ul><li>今回の場合は、header, content, footerに分けた</ul><li><code>@input()</code>や各コールバックを利用して、viewとコンポーネントでの変数のバインディングが簡単にできる<li>DIを利用しているのでそれぞれのクラスの依存度が少ない<li>TypeScriptで書けるので、記述量少なく保守性の高いソースコードを書くことができる</ul><p>後編では、Reactによる同様のToDoツールの実装と、両者の比較を行っています。ぜひご覧ください。<ul><li><a href=https://www.altus5.co.jp/blog/angularjs/react/2017/02/24/angularjs-vs-React/ >AngularJS vs React それぞれの利点と特徴（React編）</a></ul><h2 id=->参考</h2><ul><li><a href=https://html5experts.jp/canidoweb/18001/ >【βリリース記念】5分でわかる！Angular2のススメ _ HTML5Experts.jp</a><li><a href=https://jp.vuejs.org/v2/guide/comparison.html>他のフレームワークとの比較 - Vue.js.html</a><li><a href=http://wordpress.honobono-life.info/code/angular2%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%80%81bootstrap%E9%96%A2%E6%95%B0%E3%81%AE%E6%A6%82%E8%A6%81/ >Angular2のモジュール、コンポーネント、bootstrapの概要 _ VPSサーバーでWebサイト公開　備忘録　_Linux、MySQLからAJAXまで</a><li><a href=https://codezine.jp/article/detail/9700>「Angular 2」の構成単位「コンポーネント」「モジュール」を使いこなそう (1_3)：CodeZine（コードジン）</a><li><a href=http://minotaur.badwitch.io/getting-started-with-systemjs/ >SystemJS 一巡り</a><li><a href=http://dolpen.hatenablog.com/entry/2016/04/25/201343>Angular2 における Injector の話 - Dolpenの日記</a><li><a href=http://blog.yuhiisk.com/archive/2016/05/02/angular2-lifecycle-hooks.html>Angular2のLifecycle Hooksを理解する _ Yuhiisk</a></ul></div></div><div id=blog-menu><span><strong>最近の記事</strong></span><ul><li class=recent><a href=/blog/algorithm/2017/05/30/db-ukey-detect2/ >2NF・3NF・BCNFは自動生成できる　データベース正規化アルゴリズムとその実装</a><li class=recent><a href=/blog/docker/2017/05/29/letsencript/ >非公開サイトをLet&#39;s EncryptなDockerコンテナでお手軽にSSL化する方法 | 開発環境のスピード構築のために</a><li class=recent><a href=/blog/algorithm/2017/04/28/db-ukey-detect/ >超高速開発とAIに関する一考察　DBにおける候補キーの自動検出アルゴリズムを書いてみた</a><li class=recent><a href=/blog/machine-learning/2017/03/29/online-learning/ >オンライン機械学習時代の到来が技術者にもたらすもの</a><li class=recent><a href=/blog/docker/2017/03/18/docker-mirror/ >社内の開発環境でDockerイメージをミラーリングする方法 | 開発環境のスピード構築</a></ul><span><strong>タグ</strong></span><ul><li class="tag-color-label tag__0"><a href=/blog/tag/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E6%8A%80%E8%A1%93%E7%B7%8F%E8%A6%A7/ >プログラミング技術総覧 (11)</a><li class="tag-color-label tag__1"><a href=/blog/tag/Actor%E3%83%A2%E3%83%87%E3%83%AB/ >Actorモデル (1)</a><li class="tag-color-label tag__2"><a href=/blog/tag/%E3%83%AA%E3%82%A2%E3%82%AF%E3%83%86%E3%82%A3%E3%83%96%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/ >リアクティブプログラミング (1)</a><li class="tag-color-label tag__3"><a href=/blog/tag/%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92/ >機械学習 (5)</a><li class="tag-color-label tag__4"><a href=/blog/tag/%E9%9D%99%E7%9A%84%E3%82%B5%E3%82%A4%E3%83%88/ >静的サイト (1)</a><li class="tag-color-label tag__5"><a href=/blog/tag/%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89/ >環境構築 (4)</a><li class="tag-color-label tag__6"><a href=/blog/tag/Docker/ >Docker (4)</a><li class="tag-color-label tag__7"><a href=/blog/tag/AngularJS/ >AngularJS (2)</a><li class="tag-color-label tag__8"><a href=/blog/tag/React/ >React (2)</a><li class="tag-color-label tag__9"><a href=/blog/tag/%E3%82%A2%E3%83%AB%E3%82%BF%E3%82%B9%E3%83%95%E3%82%A1%E3%82%A4%E3%83%96/ >アルタスファイブ (2)</a><li class="tag-color-label tag__10"><a href=/blog/tag/Vagrant/ >Vagrant (1)</a><li class="tag-color-label tag__11"><a href=/blog/tag/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/ >プログラミング (1)</a><li class="tag-color-label tag__0"><a href=/blog/tag/Laravel/ >Laravel (1)</a><li class="tag-color-label tag__1"><a href=/blog/tag/OAuth/ >OAuth (1)</a><li class="tag-color-label tag__2"><a href=/blog/tag/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/ >アルゴリズム (2)</a><li class="tag-color-label tag__3"><a href=/blog/tag/DB/ >DB (2)</a><li class="tag-color-label tag__4"><a href="/blog/tag/Let's%20Encrypt/">Let&#39;s Encrypt (1)</a></ul></div></div><div class=w_const><div id=fb-root></div><script>(function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.8&appId=331911723808007";
            fjs.parentNode.insertBefore(js, fjs);
          }(document, 'script', 'facebook-jssdk'));</script><ul class=socialbuttons><li class=twitter><a href=https://twitter.com/share class=twitter-share-button>Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script><li class=facebook><div class=fb-like data-href={{articleUrl}} data-layout=box_count data-action=like data-size=small data-show-faces=false data-share=false></div><li class=googleplus><div class=g-plusone data-size=tall></div><script>window.___gcfg = {lang: 'ja'};
        
              (function() {
                var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
                po.src = 'https://apis.google.com/js/platform.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
              })();</script><li class=hatena><a href="http://b.hatena.ne.jp/entry/{{articleUrl | url_param_escape}}" class=hatena-bookmark-button data-hatena-bookmark-title="{{articleTitle | url_param_escape}}" data-hatena-bookmark-layout=vertical-balloon data-hatena-bookmark-lang=ja title=このエントリーをはてなブックマークに追加><img src=https://b.st-hatena.com/images/entry-button/button-only@2x.png alt=このエントリーをはてなブックマークに追加 width=20 height=20 style="border: none"></a><script src=https://b.st-hatena.com/js/bookmark_button.js charset=utf-8 async></script><li class=pocket><a data-pocket-label=pocket data-pocket-count=vertical class=pocket-btn data-lang=ja></a><script>!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script><li class=feedly><a href="//cloud.feedly.com/#subscription%2Ffeed%2F{{rssUrl | url_param_escape}}" target=blank><img id=feedlyFollow src=//s3.feedly.com/img/follows/feedly-follow-rectangle-volume-small_2x.png alt="follow us in feedly" width=66 height=20></a></ul><div class=relate><h1>関連記事</h1><ul><li class=post-link><span class=post-date>2017/02/24 </span><a class=post-title href=/blog/AngularJS/React/2017/02/24/angularjs-vs-React/ >AngularJS vs React それぞれの利点と特徴（React編） </a><span class=post-description><a href=/blog/AngularJS/React/2017/02/24/angularjs-vs-React/ >「Angular 2」「React」両フレームワークでToDoツールを作成する記事です。実装過程と成果物を比較して、両者のフレームワークの良いところ・悪いところを検証したいと思います。（React編）</a></span><li class=post-link><span class=post-date>2017/05/30 </span><a class=post-title href=/blog/algorithm/2017/05/30/db-ukey-detect2/ >2NF・3NF・BCNFは自動生成できる　データベース正規化アルゴリズムとその実装 </a><span class=post-description><a href=/blog/algorithm/2017/05/30/db-ukey-detect2/ >今回は、第二正規形（2NF）までの正規化を行うアルゴリズムを提案・実装しています。2NF、3NF、BCNFはいずれも、関数従属性を取り扱うという点で共通しています。なので、2NFの自動化ができれば、3NFやBCNFへのステップアップにはさほどの困難はなさそうです。</a></span><li class=post-link><span class=post-date>2017/04/28 </span><a class=post-title href=/blog/algorithm/2017/04/28/db-ukey-detect/ >超高速開発とAIに関する一考察　DBにおける候補キーの自動検出アルゴリズムを書いてみた </a><span class=post-description><a href=/blog/algorithm/2017/04/28/db-ukey-detect/ >正規化という概念を知らないようなユーザーでも、サンプルとなるテーブルを与えれば、正規化されたテーブルが出力されるようなアルゴリズムを考えてみました。</a></span><li class=post-link><span class=post-date>2017/03/30 </span><a class=post-title href=/blog/machine-learning/2017/03/29/online-learning/ >オンライン機械学習時代の到来が技術者にもたらすもの </a><span class=post-description><a href=/blog/machine-learning/2017/03/29/online-learning/ >「オンライン学習」とは、「データの到着が逐次的(sequential)であること」が解析に含まれているような機械学習手法を言います。いくつか、主要な概念やアルゴリズムについてまとめました。</a></span><li class=post-link><span class=post-date>2017/01/06 </span><a class=post-title href=/blog/machine-learning/2017/01/06/submodular2/ >オンライン広告をどのようにプロモーションする？ - 劣モジュラ性と局所探索で解決 </a><span class=post-description><a href=/blog/machine-learning/2017/01/06/submodular2/ >前回の記事でソーシャルマーケティングの例であるオンライン広告問題の定義と劣モジュラ性の関連について説明しました。今回はオンライン広告問題において、どのようにインフルエンサーを見つけ、プロモーションを行っていくのかを紹介したいと思います。</a></span></ul></div></div></article><article id=scout class=article><h1 class="scout_title w_const">＼(＾▽＾*) 私たちと一緒に働いてみませんか？ (*＾▽＾)／</h1><div class="article__conts w_const"><section class="content01 content"><p>少しでも興味をお持ちいただけたら、お気軽に、お問い合わせください。<p><a href=/contact/entry/ >採用応募受付へ</a><p>(採用応募じゃなく、ただ、会ってみたいという方も、大歓迎です。)</section></div></article></div><footer id=_footer><nav class=w_const><div class="content01 cf"><div class=profile><h1 class=foot_logo><a href=/ ><img src=/images/logo_footer.png alt=Altus-Five（アルタスファイブ）></a></h1><div class=address><p class=paragraph>〒160-0022<p class=paragraph>東京都新宿区新宿2-1-9 ステラ新宿5F<p class=paragraph><a href=tel:03-6904-5573>TEL：03-6904-5573</a></div></div><ul class="links links01"><li class=link><a href=/ >TOP</a><li class=link><a href=/#introduction>アルタスファイブとは</a><li class=link><a href=/#feature>強み</a><li class=link><a href=/#service>サービス</a><li class=link><a href=/#performance>実績</a><li class=link><a href=/#example>開発事例</a><li class=link><a href=/blog/ >ブログ</a></ul><ul class="links links02"><li class=link><a href=/recruit/ >採用情報</a><li class=link><a href=/company/ >会社概要</a><li class=link><a href=/privacy/ >個人情報保護方針</a><li class=link><a href=/contact/ >お問い合わせ</a></ul><ul class=marks><li class=mark><img src=/images/p_mark.png alt=""></ul></div><div id=copyright>© 2016 Altus-Five Co.,LTD. ALL RIGHTS RESERVED.</div></nav></footer><script src=/scripts/vendor.js></script><script>$(function() {
      var fout = false;
      var orgFontFamily;
      if (fout) {
        var orgFontFamily = $('body').css('font-family');
        $('body').css({'font-family': "'Helvetica', 'Arial', 'メイリオ', 'Meiryo', 'MS  PGothic', 'ヒラギノ角ゴ Pro W3', 'Hiragino Kaku Gothic Pro', sans-serif"});
      }
      WebFont.load({
        google: {
          families: [
            "PT Sans Narrow:n4,n7"
          ]
        },
        custom: {
          families: [
            "Noto Sans Japanese:n4,n7"
          ]
        },
        timeout: 3000,
        loading: function() {
          // ロードしているとき allfonts
        },
        active: function() {
          // Web Fontが使用可能になったとき allfonts
        },
        inactive: function() {
          // ブラウザがサポートしていないとき allfonts
        },
        fontloading: function(fontFamily, fontDescription) {
          // fontFamilyをロードしているとき onefont
        },
        fontactive: function(fontFamily, fontDescription) {
          // fontFamilyが使用可能になったとき onefont
          if (fout) {
            if ('Noto Sans Japanese' === fontFamily) {
              $('body').css({'font-family': orgFontFamily});
            }
          }
        },
        fontinactive: function(fontFamily, fontDescription) {
          // fontFamilyをブラウザがサポートしていないとき onefont
        }
      });
    });</script><script src=/scripts/common.js></script><script src=/scripts/jquery.tile.min.js></script><script type=text/x-mathjax-config>MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ['\\(','\\)'] ],
        processEscapes: true
      }
    });</script><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script>